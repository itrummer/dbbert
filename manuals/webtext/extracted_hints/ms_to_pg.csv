	sentence	context	pred_type	params	values
0	Be aware that if your system or Postgre SQL build is 32-bit, it might not be practical to set shared_buffers above 2 ~ 2.5GB	Be aware that if your system or Postgre SQL build is 32-bit, it might not be practical to set shared_buffers above 2 ~ 2.5GB	4	{'shared_buffers'}	['32-bit', '2', '2.5GB']
1	Setting effective_cache_size to 1/2 of total memory would be a normal conservative setting, and 3/4 of memory is a more aggressive but still reasonable amount	Setting effective_cache_size to 1/2 of total memory would be a normal conservative setting, and 3/4 of memory is a more aggressive but still reasonable amount	0	{'effective_cache_size'}	['1/2', '3/4']
2	Unless you're running on a very small configuration, you'll almost certainly be better setting this to at least 10, which also allows usefully increasing the completion target	Setting checkpoint_segments to a much larger value improves that	4	{'checkpoint_segments'}	['on', '10']
3	You can spread those writes out further, lowering the average write overhead, by increasing the checkpoint_completion_target parameter to its useful maximum of 0.9 (aim to finish by the time 90% of the next checkpoint is here) rather than the default of 0.5 (aim to finish when the next one is 50% done)	You can spread those writes out further, lowering the average write overhead, by increasing the checkpoint_completion_target parameter to its useful maximum of 0.9 (aim to finish by the time 90% of the next checkpoint is here) rather than the default of 0.5 (aim to finish when the next one is 50% done)	4	{'checkpoint_completion_target'}	['0.9', '90%', '0.5', '50%']
4	Benchmarking generally suggests that just increasing to 1MB is enough for some large systems, and given the amount of RAM in modern servers allocating a full WAL segment (16MB, the useful upper-limit here) is reasonable	On Postgre SQL 9.0 and earlier, increasing wal_buffers from its tiny default of a small number of kilobytes is helpful for write-heavy systems	4	{'wal_buffers'}	['1MB', '16MB']
5	If you do not use two phase commit (and if you don't know what it is, you don't use it), then you can set this value to 0	max_prepared_transactions	4	{'max_prepared_transactions'}	['0']
6	For obsolete versions of Postgre SQL, you may find people recommending that you set fsync=off to speed up writes on busy systems	synchronous_commit	4	{'synchronous_commit'}	['on']
7	Some feel that 4.0 is always too large on current hardware; it's not unusual for administrators to standardize on always setting this between 2.0 and 3.0 instead	RAID arrays of SCSI disks, it may be appropriate to lower random_page_cost, which will encourage the query optimizer to use random access index scans	4	{'random_page_cost'}	['4.0', 'on', 'on', '2.0', '3.0']
8	The value should be set to 15% to 25% of the machine’s total RAM	#shared_buffers = 128MB	0	{'#shared_buffers'}	['15%', '25%']
9	For example: if your machine’s RAM size is 32 GB, then the recommended value for shared_buffers is 8 GB	For example: if your machine’s RAM size is 32 GB, then the recommended value for shared_buffers is 8 GB	0	{'shared_buffers'}	['32', '8']
10	Recommendations are to set Effective_cache_size at 50% of the machine’s total RAM	Recommendations are to set Effective_cache_size at 50% of the machine’s total RAM	0	{'Effective_cache_size'}	['50%']
11	The recommended value is 25% of your total machine RAM	The default value of shared_buffer is set very low and you will not get much benefit from that	0	{'shared_buffer'}	['25%']
12	For testing purposes, let’s increase this to 256MB and see if there is any impact on cost	For the above query, we have a work_mem of only 2MB	4	{'work_mem'}	['256MB', 'on']
13	If your application is designed such that performance is more important than the reliability, then turn off synchronous_commit	If your application is designed such that performance is more important than the reliability, then turn off synchronous_commit	4	{'synchronous_commit'}	['off']
14	I understad that most of this suggestions like using 25% of RAM for shared_buffer is for servers that are only running Postgre SQL and not for servers that also run a web server or other services	I understad that most of this suggestions like using 25% of RAM for shared_buffer is for servers that are only running Postgre SQL and not for servers that also run a web server or other services	4	{'shared_buffer'}	['25%']
15	The default setting is about 3% of shared_buffers, not less than 64KB or more than the size of a WAL segment (usually 16MB)	The default setting is about 3% of shared_buffers, not less than 64KB or more than the size of a WAL segment (usually 16MB)	0	{'shared_buffers'}	['3%', '64KB', '16MB']
16	Setting this value to at least a few MB can improve write performance on a server with many concurrent transactions	The default setting is about 3% of shared_buffers, not less than 64KB or more than the size of a WAL segment (usually 16MB)	4	{'shared_buffers'}	['on']
17	A reasonable value would be 50% of the RAM	effective_cache_size	1	{'effective_cache_size'}	['50%']
18	Turn this off at your own risk	max_fsm_pages = <num> — This option helps to control	4	{'max_fsm_pages'}	['off']
