filenr,sentence,parameter,value,base,operators
1,"Even on a modern Linux system, the stock kernel will likely not allow setting shared_buffers to over 32MB without adjusting kernel settings first",shared_buffers,32MB,3,0;1
1,"If you have a system with 1GB or more of RAM, a reasonable starting value for shared_buffers is 1/4 of the memory in your system If you have less RAM you'll have to account more carefully for how much RAM the OS is taking up; closer to 15% is more typical there",shared_buffers,15%,0,2;2
1,"There are some workloads where even larger settings for shared_buffers are effective, but given the way PostgreSQL also relies on the operating system cache, it's unlikely you'll find using more than 40% of RAM to work better than a smaller amount",shared_buffers,40%,0,0;2
1,"Be aware that if your system or PostgreSQL build is 32-bit, it might not be practical to set shared_buffers above 2 ~ 2.5GB",shared_buffers,2.5GB,3,0;2
1,"Note that on Windows, large values for shared_buffers aren't as effective, and you may find better results keeping it relatively low and using the OS cache more instead On Windows the useful range is 64MB to 512MB",shared_buffers,64MB,3,2;4
1,"Note that on Windows, large values for shared_buffers aren't as effective, and you may find better results keeping it relatively low and using the OS cache more instead On Windows the useful range is 64MB to 512MB",shared_buffers,512MB,3,0;2
1,"Setting checkpoint_segments to a much larger value improves that Unless you're running on a very small configuration, you'll almost certainly be better setting this to at least 10, which also allows usefully increasing the completion target",checkpoint_segments,10,3,2;4
1,"Setting checkpoint_segments to a much larger value improves that Unless you're running on a very small configuration, you'll almost certainly be better setting this to at least 10, which also allows usefully increasing the completion target For more write-heavy systems, values from 32 (checkpoint every 512MB) to 256 (every 4GB) are popular nowadays",checkpoint_segments,32,3,2;4
1,"Setting checkpoint_segments to a much larger value improves that Unless you're running on a very small configuration, you'll almost certainly be better setting this to at least 10, which also allows usefully increasing the completion target For more write-heavy systems, values from 32 (checkpoint every 512MB) to 256 (every 4GB) are popular nowadays",checkpoint_segments,256,3,0;2
1,"Setting checkpoint_segments to a much larger value improves that Unless you're running on a very small configuration, you'll almost certainly be better setting this to at least 10, which also allows usefully increasing the completion target For more write-heavy systems, values from 32 (checkpoint every 512MB) to 256 (every 4GB) are popular nowadays  Normally the large settings (>64/1GB) are only used for bulk loading",checkpoint_segments,64,3,0;2
1,"You can spread those writes out further, lowering the average write overhead, by increasing the checkpoint_completion_target parameter to its useful maximum of 0.9 (aim to finish by the time 90% of the next checkpoint is here) rather than the default of 0.5 (aim to finish when the next one is 50% done)",checkpoint_completion_target,0.9,3,2;2
1,"On PostgreSQL 9.0 and earlier, increasing wal_buffers from its tiny default of a small number of kilobytes is helpful for write-heavy systems Benchmarking generally suggests that just increasing to 1MB is enough for some large systems, and given the amount of RAM in modern servers allocating a full WAL segment (16MB, the useful upper-limit here) is reasonable",wal_buffers,16MB,3,2;2
1,"max_prepared_transactions This setting is used for managing 2 phase commit If you do not use two phase commit (and if you don't know what it is, you don't use it), then you can set this value to 0",max_prepared_transactions,0,3,2;2
1,"RAID arrays of SCSI disks, it may be appropriate to lower random_page_cost, which will encourage the query optimizer to use random access index scans Some feel that 4.0 is always too large on current hardware; it's not unusual for administrators to standardize on always setting this between 2.0 and 3.0 instead",random_page_cost,2.0,3,2;4
1,"RAID arrays of SCSI disks, it may be appropriate to lower random_page_cost, which will encourage the query optimizer to use random access index scans Some feel that 4.0 is always too large on current hardware; it's not unusual for administrators to standardize on always setting this between 2.0 and 3.0 instead",random_page_cost,3.0,3,0;2
1,"The value should be set to 15% to 25% of the machine’s total RAM For example: if your machine’s RAM size is 32 GB, then the recommended value for shared_buffers is 8 GB",shared_buffers,15%,0,2;4
1,"The value should be set to 15% to 25% of the machine’s total RAM For example: if your machine’s RAM size is 32 GB, then the recommended value for shared_buffers is 8 GB",shared_buffers,25%,0,0;2
1,"The value should be set to 15% to 25% of the machine’s total RAM For example: if your machine’s RAM size is 32 GB, then the recommended value for shared_buffers is 8 GB",shared_buffers,8GB,3,2;2
1,Recommendations are to set Effective_cache_size at 50% of the machine’s total RAM,Effective_cache_size,50%,0,2;2
1,"The default value of shared_buffers is set very low and you will not get much benefit from that It’s low because certain machines and operating systems do not support higher values But in most modern machines, you need to increase this value for optimal performance The recommended value is 25% of your total machine RAM",shared_buffers,25%,0,2;2
1,"For the above query, we have a work_mem of only 2MB For testing purposes, let’s increase this to 256MB and see if there is any impact on cost",work_mem,256MB,3,2;2
1,"If you have a dedicated database server with 1 GB or more of RAM, a reasonable initial value for shared_buffers is 25% of your system's memory",shared_buffers,25%,0,2;2
1,effective_cache_size This value is used by the query planner to take into account plans that may or may not fit in memory This is taken into account in the cost estimates of using an index; a high value makes it more likely that index scans are used and a low value makes it more likely that sequential scans will be used A reasonable value would be 50% of the RAM,effective_cache_size,50%,0,2;2
1,shared_buffers = <num> — Editing this option is the simplest way to improve the performance of your database server The default is pretty low for most modern hardware General wisdom says that this should be set to roughly 25% of available RAM on the system,shared_buffers,25%,0,2;2
1,effective_cache_size = <num> — This value tells PostgreSQL's optimizer how much memory PostgreSQL has available for caching data and helps in determing whether or not it use an index or not The larger the value increases the likely hood of using an index This should be set to the amount of memory allocated to shared_buffers plus the amount of OS cache available Often this is more than 50% of the total system memory,effective_cache_size,50%,0,2;2
